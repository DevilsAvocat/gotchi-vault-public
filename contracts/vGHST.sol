// SPDX-License-Identifier: MIT

pragma solidity 0.8.11;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "./interfaces/IERC1155.sol";
import "./interfaces/StakingContract.sol";
import "./interfaces/Raffle.sol";
import "./interfaces/IAavegotchi.sol";


// this contract draws from QiDao's camToken
// https://github.com/0xlaozi/qidao/blob/main/contracts/camToken.sol
// stake GHST to earn more vGHST (from farming and using frens rewards)
contract vGHST is Initializable, ERC20Upgradeable, PausableUpgradeable {
    using SafeMath for uint256;
    using SafeERC20Upgradeable for IERC20Upgradeable;
    
    address public constant ghstAddress=0x385Eeac5cB85A38A9a07A70c73e0a3271CfB54A7;
    address public constant stakingAddress=0xA02d547512Bb90002807499F05495Fe9C4C3943f;
    address public constant raffleAddress=0x6c723cac1E35FE29a175b287AE242d424c52c1CE;
    address public constant diamondAddress=0x86935F11C86623deC8a25696E1C19a8659CbF95d;
    address public constant realmAddress=0x1D0360BaC7299C86Ec8E99d0c1C9A95FEfaF2a11;
    address public gotchiVaultAddress;

    uint256 constant MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;

    address public owner;
    address public contractCreator;

    uint16 public withdrawalFeeBP;

    uint256 public totalFeesCollected;


    // Define the token contract
    function initialize(
        address _owner,
        string memory name, 
        string memory symbol
        ) public initializer{

        __ERC20_init(name, symbol);

        withdrawalFeeBP = 0;
        owner = _owner;
        contractCreator = msg.sender;

    }

    modifier onlyOwner() {
        require(msg.sender ==  owner, "onlyOwner: not allowed");
        _;
    }

    function pause() public whenNotPaused{
        _pause();
    }

    function unpause() public whenPaused{
        _unpause();
    }


    
    function updateOwner(address _owner) public onlyOwner {
        owner = _owner;
    }


    function updateCreator(address _creator) public {
        require(msg.sender == contractCreator,"Can only be called by creator");
        contractCreator = _creator;
    }

    function updateGotchiVault(address _vault) public onlyOwner {
        gotchiVaultAddress = _vault;
    }

  
    //this function is to future-proof the possibility that Aavegotchi creates
    //new ERC721 or ERC1155 items with a new address.  Will want to be able to list these at the baazaar
    //both ERC721 and ERC1155 use the same "setApprovalForAll" function, so can use the IERC1155 interface for either
    function setNewDiamondApprovalERC1155(address _tokenAddress) public onlyOwner{
        IERC1155(_tokenAddress).setApprovalForAll(diamondAddress, true);
    }

    function setApprovals() public onlyOwner{

        //diamond address needs to take GHST for baazaar fees
        IERC20Upgradeable(ghstAddress).approve(diamondAddress, MAX_INT);
        
        //staking address needs to take GHST for staking GHST
        IERC20Upgradeable(ghstAddress).approve(stakingAddress, MAX_INT);

        //raffle address needs to take raffle tickets
        IERC1155(stakingAddress).setApprovalForAll(raffleAddress, true);

        //diamond address needs to take raffle tickets
        IERC1155(stakingAddress).setApprovalForAll(diamondAddress, true);

        //diamond needs to take gotchis and wearables for baazaar sales
        IERC1155(diamondAddress).setApprovalForAll(diamondAddress, true);

        //diamond needs to take realm for baazaar sales
        IERC721(realmAddress).setApprovalForAll(diamondAddress, true);
    }

    function updateWithdrawalFee(uint16 _withdrawalFee) public onlyOwner{
        withdrawalFeeBP=_withdrawalFee;
    }

    function getFee() public view returns(uint256){
        return withdrawalFeeBP;
    }

    function getTotalFees() public view returns(uint256){
        return totalFeesCollected;
    }

    /////////////////////////////////////////////////////////////////////////////////////
    //In this section, we pull from Qidao's camToken implementation to allow users to own
    //a fraction of the deposited pot, which can be compounded.  Have added view functions to 
    //see how much total GHST is held by the contract, and to convert vGHST to corresponding GHST

    // Locks ghst and mints our vGHST (shares) -- this function is largely from QiDao code
    function enter(uint256 _amount) public whenNotPaused returns(uint256)  {
        
        //the total "pool" of GHST held is a combination of the GHST directly held, and the GHST staked
        uint256 totalTokenLocked = totalGHST(address(this));

        uint256 totalShares = totalSupply(); // Gets the amount of vGHST in existence

        // Lock the Token in the contract
        IERC20Upgradeable(ghstAddress).transferFrom(msg.sender, address(this), _amount);
        StakingContract(stakingAddress).stakeIntoPool(ghstAddress, _amount);

        if (totalShares == 0 || totalTokenLocked == 0) { // If no vGHST exists, mint it 1:1 to the amount put in
                _mint(msg.sender, _amount);
                return _amount;
        } else {
            uint256 vGHSTAmount = _amount.mul(totalShares).div(totalTokenLocked);
            _mint(msg.sender, vGHSTAmount);
            return vGHSTAmount;
        }
    }

    //this function is used for the Gotchi Vault to contract to "collect" vGHST fees and "send"
    //it back to the vGHST contract
    function burn(uint256 _share) public whenNotPaused{
        require(balanceOf(msg.sender) >= _share, "Amount to burn exceeds balance");

        _burn(msg.sender, _share);
    }


    // claim ghst by burning vGHST -- this function is largely from QiDao code
    // we charge a 0.5% fee on withdrawal
    function leave(uint256 _share) public {
        if(_share>0){

            uint256 ghstAmount = convertVGHST(_share);

            //if balanceof(this) < ghst Amount (because GHST is staked for frens), unstake ghstAmount
            if(ghstAmount > IERC20Upgradeable(ghstAddress).balanceOf(address(this))){
                StakingContract(stakingAddress).withdrawFromPool(ghstAddress, ghstAmount);
            }
            _burn(msg.sender, _share);
            
            // Now we withdraw the GHST from the vGHST Pool (this contract) and send to user as GHST.
            //IERC20(usdc).safeApprove(address(this), amTokenAmount);
            //we take a designated fee from the withdrawal
            //solidity doesn't allow floating point math, so we have to multiply up to take percentages
            //here, e.g., a fee of 50 basis points would be a 0.5% fee
            //half the fee goes to the protocol, 25% goes to the contract owner, 25% goes to the contract creator 
            //we send 25% each to the owner and creator, and the remaining 50% just stays in the contract
            uint256 feeAmount = ghstAmount.mul(withdrawalFeeBP).div(10000);

            totalFeesCollected += feeAmount;

            IERC20Upgradeable(ghstAddress).transfer(owner, feeAmount.mul(100).div(400));
            IERC20Upgradeable(ghstAddress).transfer(contractCreator, feeAmount.mul(100).div(400));

            //if the sender is trying to cash out all the remaining vGHST, then half the fee goes to him
            if(totalSupply() == 0){IERC20Upgradeable(ghstAddress).transfer(msg.sender, feeAmount.mul(200).div(400));}
            
            //we send the escrow - fee to the owner
            IERC20Upgradeable(ghstAddress).transfer(msg.sender, ghstAmount.sub(feeAmount));
            
        }
    }

    //a function to get the total GHST held by an address between the wallet AND staked
    function totalGHST(address _user) public view returns(uint256 _totalGHST){
        //get the total amount of GHST held directly in the wallet
        uint256 totalGHSTHeld = IERC20Upgradeable(ghstAddress).balanceOf(_user);
        //find the total amount of GHST this contract has staked
        uint256 totalGHSTStaked = 0;

        PoolStakedOutput[] memory poolsStaked = StakingContract(stakingAddress).stakedInCurrentEpoch(_user);
        for(uint256 i = 0; i < poolsStaked.length; i++){
            if(poolsStaked[i].poolAddress == ghstAddress){
                totalGHSTStaked = poolsStaked[i].amount;
                break;
            }

        }

        _totalGHST = totalGHSTHeld + totalGHSTStaked;
    }

    function convertVGHST(uint256 _share) public view returns(uint256 _ghst){
        if(_share > 0){
            uint256 totalShares = totalSupply(); // Gets the amount of vGHST in existence

            //get the total amount of GHST held by the contract
            uint256 totalTokenLocked = totalGHST(address(this));

            //calculate how much of our total pool this share owns
            _ghst = _share.mul(totalTokenLocked).div(totalShares);
        }
        else return 0;
            
    }

    /////////////////////////////////////////////////////////////////////////////////////
    //In this section, we have wrapper functions that can be called by the owner, to stake and 
    //unstake GHST, claim raffle tickets, enter raffle tickets into raffles, sell ERC1155 items on baazaar
    //this is the core of the "compounding" part of this contract, and can only be called by the owner
    
    /////////////////////////////////////////////////////////////////////////////////////
    //Wrapper functions for the staking diamond contract
    function frens() public view returns (uint256 frens_) {
        frens_ = StakingContract(stakingAddress).frens(address(this));
    }

    function stakeIntoPool(address _poolContractAddress, uint256 _amount) public onlyOwner{
        StakingContract(stakingAddress).stakeIntoPool(_poolContractAddress, _amount);
    }

    

    function stakeAllGHST() public onlyOwner{
        StakingContract(stakingAddress).stakeIntoPool(ghstAddress, IERC20Upgradeable(ghstAddress).balanceOf(address(this)));
    }

    function withdrawFromPool(address _poolContractAddress, uint256 _amount) public onlyOwner{
        StakingContract(stakingAddress).withdrawFromPool(_poolContractAddress, _amount);
    }

    function claimTickets(uint256[] calldata _ids, uint256[] calldata _values) public onlyOwner{
        StakingContract(stakingAddress).claimTickets(_ids, _values);
    }

    function convertTickets(uint256[] calldata _ids, uint256[] calldata _values) public onlyOwner{
        StakingContract(stakingAddress).convertTickets(_ids, _values);
    }

    /////////////////////////////////////////////////////////////////////////////////////
    //Wrapper functions for the raffle contract
    function enterTickets(uint256 _raffleId, TicketItemIO[] calldata _ticketItems) public onlyOwner{
        RaffleContract(raffleAddress).enterTickets(_raffleId, _ticketItems);
    }

    function claimPrize(
        uint256 _raffleId,
        address _entrant,
        ticketWinIO[] calldata _wins
    ) public onlyOwner{
        RaffleContract(raffleAddress).claimPrize(_raffleId, _entrant, _wins);
    }

    //we need this function because the Aavegotchi contracts change their function calls for converting raffle
    //winning vouchers into ERC721 tokens (ERC1155 tokens are sent directly to the winner using claimPrize), so we need 
    //an upgradable contract or EOA to be the one actually claiming the ERC721 token from the ERC1155 vouchers
    //todo: can remove this if we end up deploying vGHST as upgradable
    function withdrawVouchers(address _voucherAddress, uint256 _id, uint256 _value) public whenNotPaused {
        require(msg.sender == owner || msg.sender == gotchiVaultAddress, "withdrawVouchers: can only be called by contract owner or the gotchiVault");
        IERC1155(_voucherAddress).safeTransferFrom(address(this), gotchiVaultAddress, _id, _value, "");
    }

    /////////////////////////////////////////////////////////////////////////////////////
    //Wrapper functions for the baazaar
    //We allow the owner to list items (e.g., raffle tickets and raffle winnings)
    function setERC1155Listing(address _erc1155TokenAddress, uint256 _erc1155TypeId, uint256 _quantity, uint256 _priceInWei) public onlyOwner{
        //we need at least 0.1 GHST (1e17) in the wallet to pay the listing fee
        //if we don't have that much, pull 5 GHST from staking pool
        if(IERC20Upgradeable(ghstAddress).balanceOf(address(this)) < 1e18){
            StakingContract(stakingAddress).withdrawFromPool(ghstAddress, 5e18);
        }
        IAavegotchi(diamondAddress).setERC1155Listing(_erc1155TokenAddress, _erc1155TypeId, _quantity, _priceInWei);
    }
    
    function cancelERC1155Listing(uint256 _listingId) public onlyOwner{
        IAavegotchi(diamondAddress).cancelERC1155Listing(_listingId);
    }

    function addERC721Listing(address _erc721TokenAddress,uint256 _erc721TokenId,uint256 _priceInWei) public onlyOwner{
        IAavegotchi(diamondAddress).addERC721Listing(_erc721TokenAddress, _erc721TokenId, _priceInWei);
    }

    function cancelERC721ListingByToken(address _erc721TokenAddress, uint256 _erc721TokenId) public onlyOwner{
        IAavegotchi(diamondAddress).cancelERC721ListingByToken(_erc721TokenAddress, _erc721TokenId);
    }

    function updateERC721Listing(address _erc721TokenAddress,uint256 _erc721TokenId,address _owner) public onlyOwner{
        IAavegotchi(diamondAddress).updateERC721Listing(_erc721TokenAddress, _erc721TokenId, _owner);
    }

    /////////////////////////////////////////////////////////////////////////////////////

    

    /////////////////////////////////////////////////////////////////////////////////////
    // We need to handle the receipt of ERC1155 and ERC721 tokens, as those will be the winnings
    // of the Aavegotchi raffles
     /**
        @notice Handle the receipt of a single ERC1155 token type.
        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.        
        This function MUST return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61) if it accepts the transfer.
        This function MUST revert if it rejects the transfer.
        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.
        @param _operator  The address which initiated the transfer (i.e. msg.sender)
        @param _from      The address which previously owned the token
        @param _id        The ID of the token being transferred
        @param _value     The amount of tokens being transferred
        @param _data      Additional data with no specified format
        @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
    */
    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _value,
        bytes calldata _data
    ) external pure returns (bytes4) {
        _operator; // silence not used warning
        _from; // silence not used warning
        _id; // silence not used warning
        _value; // silence not used warning
        _data;
        return 0xf23a6e61;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _values,
        bytes calldata _data
    ) external pure returns (bytes4){
        _operator;
        _from;
        _ids;
        _values;
        _data;
        return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"));
    }


    function onERC721Received(
        address, /* _operator */
        address, /*  _from */
        uint256, /*  _tokenId */
        bytes calldata /* _data */
    ) external pure returns (bytes4) {
        return bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
    }

    /////////////////////////////////////////////////////////////////////////////////////
}
